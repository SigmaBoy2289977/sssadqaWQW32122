--!strict
-- made by Zynic
--------------------------------VARIABLES SECTION OF THE CODE-----------------------------------
------------------------------------------------------------------------------------------------
local Octree
local library
local Iris

if httpget then
	Octree = loadstring(httpget("https://raw.githubusercontent.com/Sleitnick/rbxts-octo-tree/main/src/init.lua", true))()
	library = loadstring(httpget("https://raw.githubusercontent.com/Zyn-ic/MM2-AutoFarm/refs/heads/main/UI-Library/XSX.lua", true))()
	Iris = loadstring(httpget("https://raw.githubusercontent.com/x0581/Iris-Exploit-Bundle/2.0.4/bundle.lua"))().Init(game.CoreGui)
else
	game:GetService("StarterGui"):SetCore("SendNotification", { Title = "Using Old Method", Text = "using discontinued 'game:HttpGet'", Duration = 4 })
	Octree = loadstring(game:HttpGet("https://raw.githubusercontent.com/Sleitnick/rbxts-octo-tree/main/src/init.lua", true))()
	library = loadstring(game:HttpGet("https://raw.githubusercontent.com/Zyn-ic/MM2-AutoFarm/refs/heads/main/UI-Library/XSX.lua", true))()
	Iris = loadstring(game:HttpGet("https://raw.githubusercontent.com/x0581/Iris-Exploit-Bundle/2.0.4/bundle.lua"))().Init(game.CoreGui)
end

--local WayPointManager = loadstring(httpget("https://raw.githubusercontent.com/Zyn-ic/MM2-AutoFarm/refs/heads/main/Iris-Functions/WayPointManager", true))()

local Notif = library:InitNotifications()
library.rank = "developer"


local rt = {} -- Removable table
rt.__index = rt
rt.octree = Octree.new()

rt.Players = game:GetService("Players")
rt.RunService = game:GetService("RunService")
rt.CoreGui = game:GetService("CoreGui")
rt.TeleportService = game:GetService("TeleportService")
rt.HttpService = game:GetService("HttpService")
rt.Camera = game:GetService("Workspace").CurrentCamera

rt.IWPM = false :: boolean-- Iris WayPointManager

rt.player = rt.Players.LocalPlayer :: Player
rt.sheriff = nil :: Player 
rt.Murderer = nil :: Player 
rt.PreviousMurderer = nil :: Player
rt.Viewing = false :: boolean
rt.RoleTracker1 = nil :: RBXScriptConnection 
rt.RoleTracker2 = nil :: RBXScriptConnection 
rt.WeaponTracker1 = nil :: RBXScriptConnection 
rt.WeaponTracker2 = nil :: RBXScriptConnection
rt.Joined = nil :: RBXScriptConnection 
rt.Left = nil :: RBXScriptConnection 
rt.viewChanged = nil :: RBXScriptConnection 
rt.viewDiedFunc = nil :: RBXScriptConnection 
rt.Map = nil :: Model 

rt.flingActive = false :: boolean
rt.refresh = nil :: (boolean?) -> ()

rt.HitboxSize = nil :: number

rt.espON = false :: boolean
rt.playerESP = {}


rt.AutoFarmOn = false
rt.coinContainer = nil
rt.Material = Enum.Material.Ice :: EnumItem
rt.TpBackToStart = true :: boolean
rt.Uninterrupted = false :: boolean
rt.radius = 200 :: number -- Radius to search for coins
rt.walkspeed = 35 :: number -- speed at which you will go to a coin measured in walkspeed
rt.touchedCoins = {} -- Table to track touched coins
rt.positionChangeConnections = setmetatable({}, { __mode = "v" }) -- Weak table for connections
rt.Added = nil :: RBXScriptConnection
rt.Removing = nil :: RBXScriptConnection
rt.start = nil :: thread

rt.UserDied = nil :: RBXScriptConnection

rt.Settings = {}
rt.waypoint = nil :: CFrame
rt.Settings.WayPoints = {}


---------------------------------------LOCAL FUNCTIONS-------------------------------------------
-------------------------------------------------------------------------------------------------

-- Function to set a palyer Collision Status
-- local function setCharacterCollision (character: Model, state:boolean)
--     for _, part in pairs(character:GetDescendants()) do
--         if part:IsA("BasePart") or part:IsA("MeshPart") then
--             part.CanCollide = state
--         end
--     end
-- end

-- Function to teleport to a player
local function TeleportToPlayer(targetPlayer)
    if rt:Character() and rt:Character():FindFirstChild("HumanoidRootPart") and targetPlayer.Character and targetPlayer.Character:FindFirstChild("HumanoidRootPart") then
        rt:Character():PivotTo(targetPlayer.Character:GetPivot())
    end
end

-- Function to disconnect ESP for a player
local function RemovePlayerESP(player)
    if rt.playerESP[player] then
        rt.playerESP[player].button.Parent:Destroy()
        rt.Disconnect(rt.playerESP[player].connection1)
        rt.Disconnect(rt.playerESP[player].connection2)
        rt.Disconnect(rt.playerESP[player].connection3)
        rt.playerESP[player] = nil
    end
end

-- Function to create the UI for a player's ESP
local function CreatePlayerESP(player)
    if rt.espON == false then return end
    if rt.playerESP[player] then return end -- Prevent duplicate ESPs

    -- Create ScreenGui for the ESP
    local screenGui = Instance.new("ScreenGui")
    screenGui.Name = "CorePosition_" .. player.Name
    screenGui.Parent = game:GetService("CoreGui")

    -- Create a button for the ESP
    local button = Instance.new("TextButton")
    button.Size = UDim2.new(0, 25, 0, 25) -- Size of the button
    button.Text = "ðŸ‘¤"
    button.BackgroundColor3 = Color3.fromRGB(94, 94, 94) -- Default grey color
    button.TextSize = 14
    button.Visible = false
    button.Parent = screenGui
    Instance.new("UICorner").Parent = button -- Rounded corners

    -- Track the button and connection
    rt.playerESP[player] = { button = button, connection1 = nil, connection2 = nil, connection3 = nil }

	local lastClick = 0
	local holdingStartTime = 0
	local holding = false

	button.MouseButton1Down:Connect(function()
		holdingStartTime = tick()
		holding = true

		-- Start a task to check if the button is held for 1.5 seconds
		task.spawn(function()
			while holding do
				if tick() - holdingStartTime >= 0.3 then
					TeleportToPlayer(player) -- Teleport after 1.5 seconds
					holding = false -- Stop the loop
					break
				end
				task.wait()
			end
		end)
	end)

	button.MouseButton1Up:Connect(function()
		holding = false -- Stop checking when the button is released

		local now = tick()

		-- Handle button double-click for removing ESP
		if now - lastClick < 0.5 then
			RemovePlayerESP(player)
		end

		lastClick = now -- Update last click time
	end)


    -- Update button's position and properties each frame
    rt.playerESP[player].connection1 = rt.RunService.RenderStepped:Connect(function()
        if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            local character = player.Character
            local rootPart = character.HumanoidRootPart
            local screenPoint = rt.Camera:WorldToScreenPoint(rootPart.Position)

            -- Check if the player is on screen
            if screenPoint.Z > 0 then
                button.Position = UDim2.new(0, screenPoint.X - button.Size.X.Offset / 2, 0, screenPoint.Y - button.Size.Y.Offset / 2)
                button.Visible = true

                -- Update button text and color based on role
                if rt.Murderer ~= nil and player.Name == rt.Murderer.Name then
                    button.Text = "ðŸ”ª"
                    button.BackgroundColor3 = Color3.fromRGB(184, 88, 88) -- Red
                elseif rt.sheriff ~= nil and player.Name == rt.sheriff.Name then
                    button.Text = "ðŸ”«"
                    button.BackgroundColor3 = Color3.fromRGB(99, 99, 168) -- Blue
                else
                    button.Text = "ðŸ‘¤"
                    button.BackgroundColor3 = Color3.fromRGB(94, 94, 94) -- Grey
                end
            else
                button.Visible = false
            end
        else
            -- Update button to "dead" state
            button.Text = "ðŸ’€"
            button.BackgroundColor3 = Color3.fromRGB(0, 0, 0) -- Black
            button.Visible = true
        end
    end)

    -- Update ESP when the player dies or respawns
    rt.playerESP[player].connection2 = player.CharacterRemoving:Connect(function()
        button.Text = "ðŸ’€"
        button.BackgroundColor3 = Color3.fromRGB(0, 0, 0) -- Black
    end)

    rt.playerESP[player].connection3 = player.CharacterAdded:Connect(function()
		task.wait()
        button.Text = "ðŸ‘¤"
        button.BackgroundColor3 = Color3.fromRGB(94, 94, 94) -- Grey
        -- Refresh roles dynamically
        if rt.Murderer ~= nil and player.Name == rt.Murderer.Name then
            button.Text = "ðŸ”ª"
            button.BackgroundColor3 = Color3.fromRGB(184, 88, 88) -- Red
        elseif rt.sheriff ~= nil and player.Name == rt.sheriff.Name then
            button.Text = "ðŸ”«"
            button.BackgroundColor3 = Color3.fromRGB(99, 99, 168) -- Blue
        end
    end)

end

-- Function to refresh ESP roles dynamically
local function RefreshRoles(newMurderer, newSheriff)
    local murdererName = newMurderer or ""
    local sheriffName = newSheriff or ""

    -- Refresh all existing ESP buttons
    for player, espData in pairs(rt.playerESP) do
        local button = espData.button
        if  player.Name == murdererName then
            button.Text = "ðŸ”ª"
            button.BackgroundColor3 = Color3.fromRGB(184, 88, 88) -- Red
        elseif player.Name == sheriffName then
            button.Text = "ðŸ”«"
            button.BackgroundColor3 = Color3.fromRGB(99, 99, 168) -- Blue
        else
            button.Text = "ðŸ‘¤"
            button.BackgroundColor3 = Color3.fromRGB(94, 94, 94) -- Grey
        end
    end
end

local function createHitboxForPlayers(players, sizeArg, Trans:number ?)
    for _, v in pairs(players) do
        if v.Name == rt.player.Name then continue end
        if v.Character and v.Character:FindFirstChild('HumanoidRootPart') then
            local Size = Vector3.new(sizeArg, sizeArg, sizeArg)
            local Root = v.Character:FindFirstChild('HumanoidRootPart')
            if Root:IsA("BasePart") then
                if not sizeArg or sizeArg == 1 then
                    Root.Size = Vector3.new(2, 2, 1)
                    Root.Transparency = Trans or 0.3
                    Root.CanCollide = false;
                else
                    --reset hitbox
                    if sizeArg == 0 then Root.Size = rt:Character().PrimaryPart.Size; Root.Transparency = Trans or 1; Root.CanCollide = true; continue end
                    
                    -- set hitbox
                    Root.Size = Size
                    Root.Transparency = Trans or  0.3
                    Root.CanCollide = false;
                end
            end
        end
    end
end

---------------------------------------ATUOFARM SECTION--------------------------------------
local collectCoins
local function AutoFarmCleanUp()
    -- Check if the table is empty
    if next(rt.positionChangeConnections) == nil then
        rt.AutoFarmOn = false
        print("No items in positionChangeConnections")
        return true
    end

    rt.AutoFarmOn = false
    coroutine.yield(rt.start)
    coroutine.close(rt.start)
    if coroutine.status(rt.start) == "suspended" then
        coroutine.yield(rt.start)
        coroutine.close(rt.start)
    end
    
    -- Disconnect all connections
    for _, connection in pairs(rt.positionChangeConnections) do
        rt.Disconnect(connection)
    end
    rt.Disconnect(rt.Added)
    rt.Disconnect(rt.Removing)

    -- Notify and clean up
    Notif:Notify("Removing cached instances for AutoFarm", 1.5, "success")
    table.clear(rt.touchedCoins)
    table.clear(rt.positionChangeConnections)
    
    task.wait(1)
    rt.start = coroutine.create(collectCoins)
    return true
end


-- Function to check if a coin has been touched
local function isCoinTouched(coin)
    return rt.touchedCoins[coin]
end

-- Function to mark a coin as touched
local function markCoinAsTouched(coin)
    if not rt then return end
    rt.touchedCoins[coin] = true
    local node = rt.octree:FindFirstNode(coin)
    if node then
        rt.octree:RemoveNode(node)
    end
end

-- Function to track touch interactions
local function setupTouchTracking(coin)
    
    local touchInterest = coin:FindFirstChildWhichIsA("TouchTransmitter")
    if touchInterest then
        local connection
        connection = touchInterest.AncestryChanged:Connect(function(_, parent)
            if not rt then connection:Disconnect() return end
            if parent == nil then
                -- TouchInterest removed; mark the coin as touched
                markCoinAsTouched(coin)
                rt.Disconnect(connection)
            end
        end)
        rt.positionChangeConnections[coin] = connection
    end
end

local function setupPositionTracking(coin: MeshPart, LastPositonY: number)
    local connection
    connection = coin:GetPropertyChangedSignal("Position"):Connect(function()
        -- Check if the Y position has changed
        local currentY = coin.Position.Y
        if LastPositonY and LastPositonY ~= currentY then

            -- Remove the coin from the octree as it has been moved
            markCoinAsTouched(coin)

            rt.Disconnect(connection)
            coin:Destroy()
            return
        end
    end)
    rt.positionChangeConnections[coin] = connection
end

-- Function to populate the Octree with coins
local function populateOctree()
    rt.octree:ClearAllNodes() -- Clear previous nodes

    for _, descendant in pairs(rt.coinContainer:GetDescendants()) do
        if descendant:IsA("TouchTransmitter") then --and descendant.Material == rt.Material then
            local parentCoin = descendant.Parent
            if not isCoinTouched(parentCoin) then
                rt.octree:CreateNode(parentCoin.Position, parentCoin)
                setupTouchTracking(parentCoin)
            end
            setupPositionTracking(parentCoin, parentCoin.Position.Y)
        end
    end

    rt.Added = rt.coinContainer.DescendantAdded:Connect(function(descendant)
        if descendant:IsA("TouchTransmitter") then --and descendant.Material == rt.Material then
            local parentCoin = descendant.Parent
            if not isCoinTouched(parentCoin) then
                rt.octree:CreateNode(parentCoin.Position, parentCoin)
                setupTouchTracking(parentCoin)
                setupPositionTracking(parentCoin, parentCoin.Position.Y)
            end
        end
    end)

    rt.Removing = rt.coinContainer.DescendantRemoving:Connect(function(descendant)
        if descendant:IsA("TouchTransmitter") and descendant.Parent.Name == "Coin_Server" then
            local parentCoin = descendant.Parent
            if isCoinTouched(parentCoin) then
                markCoinAsTouched(parentCoin)
            end
        end
    end)
end

local function moveToPositionSlowly(targetPosition: Vector3, duration: number)
    rt.humanoidRootPart = rt:Character().PrimaryPart
    local startPosition = rt.humanoidRootPart.Position
    local startTime = tick()
    
    while true do
        local elapsedTime = tick() - startTime
        local alpha = math.min(elapsedTime / duration, 1)
        rt:Character():PivotTo(CFrame.new(startPosition:Lerp(targetPosition, alpha)))

        if alpha >= 1 then
            task.wait(0.2)
            break
        end

        task.wait() -- Small delay to make the movement smoother
    end
end

-- Function to collect coins
collectCoins = function ()
    -- Ensure CoinContainer exists
    rt.coinContainer = rt:Map():FindFirstChild("CoinContainer")
    rt.waypoint = rt:Character():GetPivot()
    local check = rt:MainGUI():WaitForChild("Game").CoinBags.Container.SnowToken.CurrencyFrame.Icon.Coins
    local price = "40"
    if rt:IsElite() then price = "50" end

    -- Populate Octree
    populateOctree()
    
    while rt.AutoFarmOn do
        if check.Text == price then
            Notif:Notify("Full Bag", 2, "success")
            break
        end

        -- Find nearest coin
        local nearestNode = rt.octree:GetNearest(rt:Character().PrimaryPart.Position, rt.radius, 1)[1]

        if nearestNode then
            local closestCoin = nearestNode.Object
            if not isCoinTouched(closestCoin) then
                local closestCoinPosition = closestCoin.Position
                local distance = (rt:Character().PrimaryPart.Position - closestCoinPosition).Magnitude
                local duration = distance / rt.walkspeed -- Default walk speed is 26 studs/sec

                -- Move to the coin
                moveToPositionSlowly(closestCoinPosition, duration)

                -- Mark coin as touched and clean up
                markCoinAsTouched(closestCoin)
                task.wait(0.2) -- Ensure touch is registered
            end
        else
            task.wait(1) -- No coins; retry after delay
        end
    end

    if rt.TpBackToStart then
        rt:Character():PivotTo(rt.waypoint)
    end
    AutoFarmCleanUp()
end

local function ToggleAutoFarm(value : boolean)
    if not value then
        return AutoFarmCleanUp()
    end

    if not rt:CheckIfGameInProgress() then Notif:Notify("Map must be loaded to use Autofarm", 2, "error") return false  end
    if not rt:CheckIfPlayerWasInARound() then Notif:Notify("You need to be in a round or have played a round to use the autofarm", 5, "error") return false end
    if not rt.Murderer then Notif:Notify("No Murderer found to satisfy: Round in Progress", 4, "information") return false  end
    local isAlive = rt:CheckIfPlayerIsInARound()
    local OldState = rt.Uninterrupted
    local IsMurderer = rt.player.Name == rt.Murderer.Name

    --if the player is the murderer and has on rt.Uninterrupted
    if rt.Uninterrupted and IsMurderer then rt.Uninterrupted = false; IsMurderer = not IsMurderer end

    if rt.Uninterrupted then
        rt:Character():FindFirstChildWhichIsA("Humanoid"):ChangeState(Enum.HumanoidStateType.Dead)
        repeat task.wait() until rt.player.CharacterAdded:Wait()  --rt.player:HasAppearanceLoaded()
        task.wait(1)
        TeleportToPlayer(rt.Murderer)
        --start autofarm
        Notif:Notify("Uninterrupted made it all the way", 4, "alert")
        rt.AutoFarmOn = true
        coroutine.resume(rt.start)
    else
        if rt.Uninterrupted ~= OldState then rt.Uninterrupted = OldState end

        if IsMurderer then
            if not isAlive then Notif:Notify("Died before you could start? sad ngl ", 4, "alert") return false end 
            --start autofarm
            Notif:Notify("Collect sum coins Murderer!", 4, "alert")
            rt.AutoFarmOn = true
            coroutine.resume(rt.start)
        else
            --start autofarm
            if not isAlive then TeleportToPlayer(rt.Murderer) end
            Notif:Notify("Normal made it all the way", 4, "alert")
            rt.AutoFarmOn = true
            coroutine.resume(rt.start)
        end
    end

    return true
end

--------------------------------FUNCTIONS SECTION OF THE CODE-----------------------------------
------------------------------------------------------------------------------------------------

function rt:MainGUI () : (ScreenGui)
    return rt.player.PlayerGui.MainGUI or rt.player.PlayerGui:WaitForChild("MainGUI")
end

function rt:Character () : (Model)
    return self.player.Character or self.player.CharacterAdded:Wait()
end

function rt.Disconnect (connection:RBXScriptConnection)
    if connection and connection.Connected then
        connection:Disconnect()
    end
end

function rt.FindPlayer(val : string) : (Player)
    local match
    for _, v : Player in pairs(rt.Players:GetChildren()) do
        if string.match(v.Name:lower(), val:lower()) or string.match(v.DisplayName:lower(), val:lower()) then
            match = v
        end
    end

    return match
end

function rt:Map () : (Model | nil)
    for _, v in workspace:GetDescendants() do
        if v.Name == "Spawns" and v.Parent.Name ~= "Lobby"  then
            return v.Parent
        end
    end
    return nil
end

function rt:CheckForConnection () : (boolean) -- if someone reload the script while script this will help us know
    if self.player:GetAttribute("Connection") then
        return true
    end
    
    return false
end

function rt:IsElite()
